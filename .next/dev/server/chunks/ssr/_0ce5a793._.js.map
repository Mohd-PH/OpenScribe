{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/sammargolis/OpenScribe/app/actions.ts"],"sourcesContent":["\"use server\"\n\nimport { generateText } from \"ai\"\nimport { createOpenAI } from \"@ai-sdk/openai\"\n\nexport async function transcribeAudio(audioBlob: Blob, apiKey: string | null): Promise<string> {\n  console.log(\"=\".repeat(80))\n  console.log(\"TRANSCRIBING AUDIO\")\n  console.log(\"=\".repeat(80))\n  console.log(`Audio blob size: ${audioBlob.size} bytes`)\n  console.log(`Audio blob type: ${audioBlob.type}`)\n  \n  if (!apiKey) {\n    console.warn(\"‚ö†Ô∏è  No API key provided - transcription will fail\")\n    throw new Error(\"API key required for transcription\")\n  }\n\n  try {\n    const formData = new FormData()\n    // Determine file extension based on blob type\n    let filename = \"audio.webm\"\n    if (audioBlob.type.includes(\"mp4\")) {\n      filename = \"audio.mp4\"\n    } else if (audioBlob.type.includes(\"mpeg\")) {\n      filename = \"audio.mpeg\"\n    } else if (audioBlob.type.includes(\"wav\")) {\n      filename = \"audio.wav\"\n    }\n    \n    formData.append(\"file\", audioBlob, filename)\n    formData.append(\"model\", \"whisper-1\")\n    \n    console.log(\"üì§ Sending audio to Whisper API...\")\n    \n    const response = await fetch(\"https://api.openai.com/v1/audio/transcriptions\", {\n      method: \"POST\",\n      headers: { Authorization: `Bearer ${apiKey}` },\n      body: formData,\n    })\n\n    if (!response.ok) {\n      const errorText = await response.text()\n      console.error(\"‚ùå Whisper API error:\", response.status, errorText)\n      throw new Error(`Whisper API error: ${response.status} - ${errorText}`)\n    }\n\n    const result = await response.json()\n    const transcript = result.text || \"\"\n    \n    console.log(\"=\".repeat(80))\n    console.log(\"TRANSCRIPTION COMPLETE\")\n    console.log(\"=\".repeat(80))\n    console.log(\"TRANSCRIBED TEXT:\")\n    console.log(\"-\".repeat(80))\n    console.log(transcript)\n    console.log(\"-\".repeat(80))\n    console.log(`Transcript length: ${transcript.length} characters`)\n    console.log(\"=\".repeat(80))\n    \n    return transcript\n  } catch (error) {\n    console.error(\"‚ùå Transcription failed:\", error)\n    throw error\n  }\n}\n\nexport async function generateClinicalNote(params: {\n  transcript: string\n  patient_name: string\n  visit_reason: string\n  apiKey: string | null\n}): Promise<string> {\n  const { transcript, patient_name, visit_reason, apiKey } = params\n\n  const systemPrompt = `You are a clinical documentation assistant that converts patient encounter transcripts into structured clinical notes.\n\nIMPORTANT INSTRUCTIONS:\n- Output ONLY plain text in the exact format shown below\n- Do NOT use JSON, markdown code blocks, or any special formatting\n- Use ONLY information explicitly stated in the transcript itself\n- Do NOT use patient name or visit reason to infer or invent any information\n- If a section has no relevant information in the transcript, leave it completely empty (just the section header followed by a blank line)\n- Do NOT add placeholder text like \"Not discussed\", \"Not documented\", \"Not performed\", or any other defaults\n- Do NOT infer, assume, or invent information - only include what is explicitly stated in the transcript\n- If the transcript is empty or has no relevant content, ALL sections must be left empty\n- Use professional medical terminology while keeping notes concise\n- This is a DRAFT that requires clinician review\n\nOUTPUT FORMAT (follow exactly):\n\nChief Complaint:\n[Primary reason for visit in 1-2 sentences, or leave empty if not stated]\n\nHPI:\n[History of present illness - onset, duration, character, severity, modifying factors, or leave empty if not stated]\n\nROS:\n[Review of systems - symptoms mentioned, organized by system, or leave empty if not stated]\n\nPhysical Exam:\n[Any exam findings mentioned, or leave empty if not stated]\n\nAssessment:\n[Clinical assessment/diagnosis mentioned by clinician, or leave empty if not stated]\n\nPlan:\n[Treatment plan discussed with patient, or leave empty if not stated]`\n\n  console.log(\"=\".repeat(80))\n  console.log(\"GENERATING CLINICAL NOTE\")\n  console.log(\"=\".repeat(80))\n  console.log(`Patient Name: ${patient_name || \"Not provided\"}`)\n  console.log(`Visit Reason: ${visit_reason || \"Not provided\"}`)\n  console.log(`Transcript length: ${transcript.length} characters`)\n  \n  // If transcript is empty, return empty note structure\n  if (!transcript || transcript.trim().length === 0) {\n    console.log(\"‚ö†Ô∏è  Transcript is empty - returning empty note structure\")\n    const emptyNote = `Chief Complaint:\n\n\nHPI:\n\n\nROS:\n\n\nPhysical Exam:\n\n\nAssessment:\n\n\nPlan:`\n    console.log(\"=\".repeat(80))\n    console.log(\"FINAL CLINICAL NOTE (EMPTY):\")\n    console.log(\"-\".repeat(80))\n    console.log(emptyNote)\n    console.log(\"-\".repeat(80))\n    console.log(\"=\".repeat(80))\n    return emptyNote\n  }\n\n  console.log(\"üìù Transcript being used for note generation:\")\n  console.log(\"-\".repeat(80))\n  console.log(transcript)\n  console.log(\"-\".repeat(80))\n\n  const userPrompt = `Convert this clinical encounter transcript into a structured note. Use ONLY the information explicitly stated in the transcript below. Do not infer or invent any information.\n\nPatient Name: ${patient_name || \"Not provided\"} (for reference only - do not use to infer information)\nVisit Reason: ${visit_reason || \"Not provided\"} (for reference only - do not use to infer information)\n\nTRANSCRIPT:\n${transcript}\n\nGenerate the clinical note now, following the exact format specified. Only include information explicitly stated in the transcript above.`\n\n  try {\n    console.log(\"ü§ñ Calling LLM to generate clinical note...\")\n    let text: string\n    \n    if (apiKey) {\n      const openai = createOpenAI({ apiKey })\n      const result = await generateText({\n        model: openai(\"gpt-4o\"),\n        system: systemPrompt,\n        prompt: userPrompt,\n      })\n      text = result.text\n    } else {\n      // Fallback to AI Gateway (no API key needed)\n      const result = await generateText({\n        model: \"openai/gpt-4o\",\n        system: systemPrompt,\n        prompt: userPrompt,\n      })\n      text = result.text\n    }\n    \n    console.log(\"=\".repeat(80))\n    console.log(\"FINAL CLINICAL NOTE:\")\n    console.log(\"=\".repeat(80))\n    console.log(text)\n    console.log(\"=\".repeat(80))\n    console.log(`Note length: ${text.length} characters`)\n    console.log(\"=\".repeat(80))\n    \n    return text\n  } catch (error) {\n    console.error(\"‚ùå AI generation error:\", error)\n    throw new Error(`Failed to generate note: ${error instanceof Error ? error.message : \"Unknown error\"}`)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///Users/sammargolis/OpenScribe/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {transcribeAudio as '60131ca343eff8da86fa092aac608eadb8489c6878'} from 'ACTIONS_MODULE0'\nexport {generateClinicalNote as '40b2687437ea74cc4409f66ee4a755835b9c89eea3'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}